declare var _default: "\n\n// borders sequences are : x:TOP, y:RIGHT, z:BOTTOM, w:LEFT\nuniform vec4 borderWidth;\nuniform vec3 borderColor;\nuniform float borderOpacity;\nuniform vec4 borderRadius;\n\nvarying vec2 vUvB;\n\n// Borders\nfloat getEdgeDist() {\n\n\t// This allows to go the uv position in a [-1, 1] referencial system\n\tvec2 ndc = vec2( vUvB.x * 2.0 - 1.0, vUvB.y * 2.0 - 1.0 );\n\n\t//\n\tvec2 planeSpaceCoord = vec2( frameSize.x * 0.5 * ndc.x, frameSize.y * 0.5 * ndc.y );\n\tvec2 corner = frameSize * 0.5;\n\tvec2 offsetCorner = corner - abs( planeSpaceCoord );\n\n\tfloat innerRadDist = min( offsetCorner.x, offsetCorner.y ) * -1.0;\n\n\tif (vUvB.x < 0.5 && vUvB.y >= 0.5) {\n\t\tfloat roundedDist = length( max( abs( planeSpaceCoord ) - frameSize * 0.5 + borderRadius.x, 0.0 ) ) - borderRadius.x;\n\t\tfloat s = step( innerRadDist * -1.0, borderRadius.x );\n\t\treturn mix( innerRadDist, roundedDist, s );\n\t}\n\tif (vUvB.x >= 0.5 && vUvB.y >= 0.5) {\n\t\tfloat roundedDist = length( max( abs( planeSpaceCoord ) - frameSize * 0.5 + borderRadius.y, 0.0 ) ) - borderRadius.y;\n\t\tfloat s = step( innerRadDist * -1.0, borderRadius.y );\n\t\treturn mix( innerRadDist, roundedDist, s );\n\t}\n\tif (vUvB.x >= 0.5 && vUvB.y < 0.5) {\n\t\tfloat roundedDist = length( max( abs( planeSpaceCoord ) - frameSize * 0.5 + borderRadius.z, 0.0 ) ) - borderRadius.z;\n\t\tfloat s = step( innerRadDist * -1.0, borderRadius.z );\n\t\treturn mix( innerRadDist, roundedDist, s );\n\t}\n\tif (vUvB.x < 0.5 && vUvB.y < 0.5) {\n\t\tfloat roundedDist = length( max( abs( planeSpaceCoord ) - frameSize * 0.5 + borderRadius.w, 0.0 ) ) - borderRadius.w;\n\t\tfloat s = step( innerRadDist * -1.0, borderRadius.w );\n\t\treturn mix( innerRadDist, roundedDist, s );\n\t}\n}\n\n";
export default _default;
